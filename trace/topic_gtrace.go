// Code generated by gtrace. DO NOT EDIT.

package trace

import (
	"context"
)

// topicReaderComposeOptions is a holder of options
type topicReaderComposeOptions struct {
	panicCallback func(e interface{})
}

// TopicReaderOption specified TopicReader compose option
type TopicReaderComposeOption func(o *topicReaderComposeOptions)

// WithTopicReaderPanicCallback specified behavior on panic
func WithTopicReaderPanicCallback(cb func(e interface{})) TopicReaderComposeOption {
	return func(o *topicReaderComposeOptions) {
		o.panicCallback = cb
	}
}

// Compose returns a new TopicReader which has functional fields composed both from t and x.
func (t TopicReader) Compose(x TopicReader, opts ...TopicReaderComposeOption) (ret TopicReader) {
	options := topicReaderComposeOptions{}
	for _, opt := range opts {
		opt(&options)
	}
	{
		h1 := t.OnPartitionReadStart
		h2 := x.OnPartitionReadStart
		ret.OnPartitionReadStart = func(o OnPartitionReadStartInfo) {
			if options.panicCallback != nil {
				defer func() {
					if e := recover(); e != nil {
						options.panicCallback(e)
					}
				}()
			}
			if h1 != nil {
				h1(o)
			}
			if h2 != nil {
				h2(o)
			}
		}
	}
	{
		h1 := t.OnPartitionReadStop
		h2 := x.OnPartitionReadStop
		ret.OnPartitionReadStop = func(info OnPartitionReadStopInfo) {
			if options.panicCallback != nil {
				defer func() {
					if e := recover(); e != nil {
						options.panicCallback(e)
					}
				}()
			}
			if h1 != nil {
				h1(info)
			}
			if h2 != nil {
				h2(info)
			}
		}
	}
	{
		h1 := t.OnPartitionCommittedNotify
		h2 := x.OnPartitionCommittedNotify
		ret.OnPartitionCommittedNotify = func(o OnPartitionCommittedInfo) {
			if options.panicCallback != nil {
				defer func() {
					if e := recover(); e != nil {
						options.panicCallback(e)
					}
				}()
			}
			if h1 != nil {
				h1(o)
			}
			if h2 != nil {
				h2(o)
			}
		}
	}
	return ret
}
func (t TopicReader) onPartitionReadStart(o OnPartitionReadStartInfo) {
	fn := t.OnPartitionReadStart
	if fn == nil {
		return
	}
	fn(o)
}
func (t TopicReader) onPartitionReadStop(info OnPartitionReadStopInfo) {
	fn := t.OnPartitionReadStop
	if fn == nil {
		return
	}
	fn(info)
}
func (t TopicReader) onPartitionCommittedNotify(o OnPartitionCommittedInfo) {
	fn := t.OnPartitionCommittedNotify
	if fn == nil {
		return
	}
	fn(o)
}
func TopicReaderOnPartitionReadStart(t TopicReader, partitionContext context.Context, topic string, partitionID int64, readOffset *int64, commitOffset *int64) {
	var p OnPartitionReadStartInfo
	p.PartitionContext = partitionContext
	p.Topic = topic
	p.PartitionID = partitionID
	p.ReadOffset = readOffset
	p.CommitOffset = commitOffset
	t.onPartitionReadStart(p)
}
func TopicReaderOnPartitionReadStop(t TopicReader, partitionContext context.Context, topic string, partitionID int64, partitionSessionID int64, committedOffset int64, graceful bool) {
	var p OnPartitionReadStopInfo
	p.PartitionContext = partitionContext
	p.Topic = topic
	p.PartitionID = partitionID
	p.PartitionSessionID = partitionSessionID
	p.CommittedOffset = committedOffset
	p.Graceful = graceful
	t.onPartitionReadStop(p)
}
func TopicReaderOnPartitionCommittedNotify(t TopicReader, topic string, partitionID int64, committedOffset int64) {
	var p OnPartitionCommittedInfo
	p.Topic = topic
	p.PartitionID = partitionID
	p.CommittedOffset = committedOffset
	t.onPartitionCommittedNotify(p)
}
