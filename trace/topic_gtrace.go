// Code generated by gtrace. DO NOT EDIT.

package trace

import (
	"context"
)

// topicComposeOptions is a holder of options
type topicComposeOptions struct {
	panicCallback func(e interface{})
}

// TopicOption specified Topic compose option
type TopicComposeOption func(o *topicComposeOptions)

// WithTopicPanicCallback specified behavior on panic
func WithTopicPanicCallback(cb func(e interface{})) TopicComposeOption {
	return func(o *topicComposeOptions) {
		o.panicCallback = cb
	}
}

// Compose returns a new Topic which has functional fields composed both from t and x.
func (t Topic) Compose(x Topic, opts ...TopicComposeOption) (ret Topic) {
	options := topicComposeOptions{}
	for _, opt := range opts {
		opt(&options)
	}
	{
		h1 := t.OnPartitionReadStart
		h2 := x.OnPartitionReadStart
		ret.OnPartitionReadStart = func(o OnPartitionReadStartInfo) {
			if options.panicCallback != nil {
				defer func() {
					if e := recover(); e != nil {
						options.panicCallback(e)
					}
				}()
			}
			if h1 != nil {
				h1(o)
			}
			if h2 != nil {
				h2(o)
			}
		}
	}
	{
		h1 := t.OnPartitionReadStop
		h2 := x.OnPartitionReadStop
		ret.OnPartitionReadStop = func(info OnPartitionReadStopInfo) {
			if options.panicCallback != nil {
				defer func() {
					if e := recover(); e != nil {
						options.panicCallback(e)
					}
				}()
			}
			if h1 != nil {
				h1(info)
			}
			if h2 != nil {
				h2(info)
			}
		}
	}
	{
		h1 := t.OnPartitionCommittedNotify
		h2 := x.OnPartitionCommittedNotify
		ret.OnPartitionCommittedNotify = func(o OnPartitionCommittedInfo) {
			if options.panicCallback != nil {
				defer func() {
					if e := recover(); e != nil {
						options.panicCallback(e)
					}
				}()
			}
			if h1 != nil {
				h1(o)
			}
			if h2 != nil {
				h2(o)
			}
		}
	}
	return ret
}
func (t Topic) onPartitionReadStart(o OnPartitionReadStartInfo) {
	fn := t.OnPartitionReadStart
	if fn == nil {
		return
	}
	fn(o)
}
func (t Topic) onPartitionReadStop(info OnPartitionReadStopInfo) {
	fn := t.OnPartitionReadStop
	if fn == nil {
		return
	}
	fn(info)
}
func (t Topic) onPartitionCommittedNotify(o OnPartitionCommittedInfo) {
	fn := t.OnPartitionCommittedNotify
	if fn == nil {
		return
	}
	fn(o)
}
func TopicOnPartitionReadStart(t Topic, partitionContext context.Context, topic string, partitionID int64, readOffset *int64, commitOffset *int64) {
	var p OnPartitionReadStartInfo
	p.PartitionContext = partitionContext
	p.Topic = topic
	p.PartitionID = partitionID
	p.ReadOffset = readOffset
	p.CommitOffset = commitOffset
	t.onPartitionReadStart(p)
}
func TopicOnPartitionReadStop(t Topic, partitionContext context.Context, topic string, partitionID int64, partitionSessionID int64, committedOffset int64, graceful bool) {
	var p OnPartitionReadStopInfo
	p.PartitionContext = partitionContext
	p.Topic = topic
	p.PartitionID = partitionID
	p.PartitionSessionID = partitionSessionID
	p.CommittedOffset = committedOffset
	p.Graceful = graceful
	t.onPartitionReadStop(p)
}
func TopicOnPartitionCommittedNotify(t Topic, topic string, partitionID int64, committedOffset int64) {
	var p OnPartitionCommittedInfo
	p.Topic = topic
	p.PartitionID = partitionID
	p.CommittedOffset = committedOffset
	t.onPartitionCommittedNotify(p)
}
